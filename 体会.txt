(1)单一职责原则(SRP),就一个类而言，应该仅有一个引起变化的原因.
	这个原则在实际应用中，很难去做区分，尽量保证模块，类的原子性就好，不用刻意
去将就。
(2)开放-封闭原则
	软件实体（类，模块、函数等等）,应该具有拓展性，不可修改，这条原则在实际应
用相当高。对拓展是开放的，修改是关闭的。

(3)依赖倒转原则
	高层模块不应该依赖低层模块，粮改都应该依赖抽象。
	抽象不应该依赖细节。细节应该依赖抽象。
(4)里氏代换原则
	子类型必须能替换掉它们的父类型。
(5)迪米特法则: 如果两个类不彼此直接通信，name这两个类就不应当发生直接的相互作用。
如果其中一个类需要调用另外个类的某一方法的话，可以通过第三者转发这个调用。
	
	
装饰者模式:
	动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为
灵活。
	装饰模式是为已有功能动态地添加更多功能的一种方式。适用，当系统需要新功能的
时候


代理模式： 为其他对象提供一种代理以控制对这个对象的访问。
	适用： 1)远程代理，为一个对象在不同的地址空间提供局部代表，这样可以隐藏一个
对象存在不同地址空间的事实。
		   2) 虚拟代理，是根据需要创建开销很对的对象。通过它存放实例化需要长时
		    间的真实对象
		   3）安全代理,用来控制真实对象访问时的权限。
		   4)智能指引，指当调用真实的对象事，代理处理另外些事。
		   
原型模式： 
	用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
	
模板方法模式:
	通过把不变行为搬移到超累，去除子类中的重复代码体现它的优势。
	
外观模式: 为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层呢个接口，
这个接口使得这子系统更加容易使用。